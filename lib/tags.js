"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const atom_1 = require("atom");
const os_1 = require("os");
const path_1 = require("path");
const child_process_1 = require("child_process");
class Tags {
    constructor() {
        this.inProgress = false;
        this.disposables = new atom_1.CompositeDisposable();
        this.tags = new Map();
        this.paths = atom.project.getPaths();
        this.filesChanged = (evts) => {
            for (const evt of evts) {
                if (!evt.path.endsWith('.hs') && !evt.path.endsWith('.lhs'))
                    continue;
                switch (evt.action) {
                    case 'created':
                        this.update(evt.path);
                        break;
                    case 'modified':
                        this.update(evt.path);
                        break;
                    case 'deleted':
                        this.tags.delete(evt.path);
                        break;
                    case 'renamed':
                        this.tags.delete(evt.oldPath);
                        this.update(evt.path);
                        break;
                }
            }
        };
        this.pathsChanged = (paths) => {
            const removedPaths = this.paths.filter((p) => !paths.includes(p));
            const addedPaths = paths.filter((p) => !this.paths.includes(p));
            if (removedPaths.length > 0) {
                Array.from(this.tags.keys())
                    .filter((f) => removedPaths.some((p) => f.startsWith(p + path_1.sep)))
                    .forEach((k) => this.tags.delete(k));
            }
            for (const path of addedPaths) {
                this.update(path);
            }
            this.paths = paths;
        };
        this.disposables.add(atom.project.onDidChangeFiles(this.filesChanged));
        this.disposables.add(atom.project.onDidChangePaths(this.pathsChanged));
        for (const path of this.paths) {
            this.update(path);
        }
    }
    destroy() {
        this.disposables.dispose();
        this.tags.clear();
    }
    update(path) {
        this.inProgress = true;
        let fn = false;
        let curfile = new Map();
        let cmd = atom.config.get('ide-haskell-hasktags.hasktagsPath');
        const env = Object.create(process.env);
        const args = [];
        if (cmd === 'hasktags.js') {
            env.ELECTRON_RUN_AS_NODE = 1;
            env.ELECTRON_NO_ATTACH_CONSOLE = 1;
            cmd = process.execPath;
            args.push('--no-deprecation');
            args.push(require.resolve('@atom-haskell/hasktags-js'));
        }
        args.push('-eRo-');
        if (atom.config.get('ide-haskell-hasktags.ignoreCloseImplementation')) {
            args.push('--ignore-close-implementation');
        }
        args.push(path);
        child_process_1.execFile(cmd, args, { env, encoding: 'utf8', maxBuffer: Infinity }, (error, data, stderr) => {
            try {
                if (error) {
                    switch (stderr) {
                        case '<stdout>: hFlush: illegal operation (handle is closed)':
                            break;
                        default:
                            console.warn('hasktags stderr', stderr);
                            atom.notifications.addError('Failed to run hasktags', {
                                detail: error.message,
                                stack: error.stack,
                                dismissable: true,
                            });
                            return;
                    }
                }
                const lines = data.split(os_1.EOL);
                for (const line of lines.slice(0, -1)) {
                    switch (true) {
                        case line === '\x0c':
                            fn = true;
                            break;
                        case fn:
                            fn = false;
                            const res = /^(.*),\d+$/.exec(line);
                            if (res === null)
                                continue;
                            const [, src] = res;
                            curfile = new Map();
                            this.tags.set(src, curfile);
                            break;
                        default:
                            const rxr = /^(.*)\x7f(.*)\x01(\d+),(\d+)$/.exec(line);
                            if (rxr === null)
                                continue;
                            const [, context, tagName, lineNo] = rxr;
                            let obj = curfile.get(tagName);
                            if (obj === undefined) {
                                obj = [];
                                curfile.set(tagName, obj);
                            }
                            obj.push({ context, line: parseInt(lineNo, 10) });
                    }
                }
            }
            finally {
                this.inProgress = false;
            }
        });
    }
    listTags(uri) {
        const res = [];
        if (!uri) {
            this.tags.forEach((tagMap, uri) => tagMap.forEach((lines, tag) => lines.forEach(({ context, line }) => res.push({ tag, uri, context, line }))));
        }
        else {
            const tagMap = this.tags.get(uri);
            if (tagMap !== undefined) {
                tagMap.forEach((lines, tag) => lines.forEach(({ context, line }) => res.push({ tag, uri, context, line })));
            }
        }
        return res;
    }
    findTag(tag) {
        const res = [];
        this.tags.forEach((tagMap, uri) => {
            const lines = tagMap.get(tag);
            if (lines === undefined)
                return;
            lines.forEach(({ context, line }) => {
                res.push({ tag, uri, context, line });
            });
        });
        return res;
    }
}
exports.Tags = Tags;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFncy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy90YWdzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0JBQWlFO0FBQ2pFLDJCQUF3QjtBQUN4QiwrQkFBMEI7QUFDMUIsaURBQXdDO0FBVXhDLE1BQWEsSUFBSTtJQUtmO1FBSk8sZUFBVSxHQUFZLEtBQUssQ0FBQTtRQUMxQixnQkFBVyxHQUFHLElBQUksMEJBQW1CLEVBQUUsQ0FBQTtRQUN2QyxTQUFJLEdBQVEsSUFBSSxHQUFHLEVBQUUsQ0FBQTtRQUNyQixVQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQTtRQXNIL0IsaUJBQVksR0FBRyxDQUFDLElBQTJCLEVBQUUsRUFBRTtZQUNyRCxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTtnQkFDdEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDO29CQUFFLFNBQVE7Z0JBQ3JFLFFBQVEsR0FBRyxDQUFDLE1BQU0sRUFBRTtvQkFDbEIsS0FBSyxTQUFTO3dCQUNaLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFBO3dCQUNyQixNQUFLO29CQUNQLEtBQUssVUFBVTt3QkFDYixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQTt3QkFDckIsTUFBSztvQkFDUCxLQUFLLFNBQVM7d0JBQ1osSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFBO3dCQUMxQixNQUFLO29CQUNQLEtBQUssU0FBUzt3QkFFWixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBUSxDQUFDLENBQUE7d0JBQzlCLElBQUksQ0FBQyxNQUFNLENBQUMs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RyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFBO1lBQ3ZDLENBQUMsQ0FBQyxDQUFBO1FBQ0osQ0FBQyxDQUFDLENBQUE7UUFDRixPQUFPLEdBQUcsQ0FBQTtJQUNaLENBQUM7Q0FxQ0Y7QUE3SkQsb0JBNkpDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9zaXRlRGlzcG9zYWJsZSwgRmlsZXN5c3RlbUNoYW5nZUV2ZW50IH0gZnJvbSAnYXRvbSdcbmltcG9ydCB7IEVPTCB9IGZyb20gJ29zJ1xuaW1wb3J0IHsgc2VwIH0gZnJvbSAncGF0aCdcbmltcG9ydCB7IGV4ZWNGaWxlIH0gZnJvbSAnY2hpbGRfcHJvY2VzcydcblxuaW50ZXJmYWNlIExpbmVSZWMge1xuICBjb250ZXh0OiBzdHJpbmdcbiAgbGluZTogbnVtYmVyXG59XG5cbnR5cGUgRmlsZVJlYyA9IE1hcDxzdHJpbmcsIExpbmVSZWNbXT5cbnR5cGUgUmVjID0gTWFwPHN0cmluZywgRmlsZVJlYz5cblxuZXhwb3J0IGNsYXNzIFRhZ3Mge1xuICBwdWJsaWMgaW5Qcm9ncmVzczogYm9vbGVhbiA9IGZhbHNlXG4gIHByaXZhdGUgZGlzcG9zYWJsZXMgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpXG4gIHByaXZhdGUgdGFnczogUmVjID0gbmV3IE1hcCgpXG4gIHByaXZhdGUgcGF0aHMgPSBhdG9tLnByb2plY3QuZ2V0UGF0aHMoKVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRpc3Bvc2FibGVzLmFkZChhdG9tLnByb2plY3Qub25EaWRDaGFuZ2VGaWxlcyh0aGlzLmZpbGVzQ2hhbmdlZCkpXG4gICAgdGhpcy5kaXNwb3NhYmxlcy5hZGQoYXRvbS5wcm9qZWN0Lm9uRGlkQ2hhbmdlUGF0aHModGhpcy5wYXRoc0NoYW5nZWQpKVxuICAgIGZvciAoY29uc3QgcGF0aCBvZiB0aGlzLnBhdGhzKSB7XG4gICAgICB0aGlzLnVwZGF0ZShwYXRoKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMuZGlzcG9zYWJsZXMuZGlzcG9zZSgpXG4gICAgdGhpcy50YWdzLmNsZWFyKClcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUocGF0aDogc3RyaW5nKSB7XG4gICAgdGhpcy5pblByb2dyZXNzID0gdHJ1ZVxuICAgIGxldCBmbjogYm9vbGVhbiA9IGZhbHNlXG4gICAgbGV0IGN1cmZpbGU6IE1hcDxzdHJpbmcsIExpbmVSZWNbXT4gPSBuZXcgTWFwKClcbiAgICBsZXQgY21kOiBzdHJpbmcgfCB1bmRlZmluZWQgPSBhdG9tLmNvbmZpZy5nZXQoXG4gICAgICAnaWRlLWhhc2tlbGwtaGFza3RhZ3MuaGFza3RhZ3NQYXRoJyxcbiAgICApXG4gICAgY29uc3QgZW52ID0gT2JqZWN0LmNyZWF0ZShwcm9jZXNzLmVudilcbiAgICBjb25zdCBhcmdzID0gW11cbiAgICBpZiAoY21kID09PSAnaGFza3RhZ3MuanMnKSB7XG4gICAgICBlbnYuRUxFQ1RST05fUlVOX0FTX05PREUgPSAxXG4gICAgICBlbnYuRUxFQ1RST05fTk9fQVRUQUNIX0NPTlNPTEUgPSAxXG4gICAgICBjbWQgPSBwcm9jZXNzLmV4ZWNQYXRoXG4gICAgICBhcmdzLnB1c2goJy0tbm8tZGVwcmVjYXRpb24nKVxuICAgICAgYXJncy5wdXNoKHJlcXVpcmUucmVzb2x2ZSgnQGF0b20taGFza2VsbC9oYXNrdGFncy1qcycpKVxuICAgIH1cbiAgICBhcmdzLnB1c2goJy1lUm8tJylcbiAgICBpZiAoYXRvbS5jb25maWcuZ2V0KCdpZGUtaGFza2VsbC1oYXNrdGFncy5pZ25vcmVDbG9zZUltcGxlbWVudGF0aW9uJykpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1pZ25vcmUtY2xvc2UtaW1wbGVtZW50YXRpb24nKVxuICAgIH1cbiAgICBhcmdzLnB1c2gocGF0aClcbiAgICBleGVjRmlsZShjbWQsIGFyZ3MsIHsgZW52LCBlbmNvZGluZzogJ3V0ZjgnLCBtYXhCdWZmZXI6IEluZmluaXR5IH0sIChlcnJvciwgZGF0YSwgc3RkZXJyKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBzd2l0Y2ggKHN0ZGVycikge1xuICAgICAgICAgICAgY2FzZSAnPHN0ZG91dD46IGhGbHVzaDogaWxsZWdhbCBvcGVyYXRpb24gKGhhbmRsZSBpcyBjbG9zZWQpJzpcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignaGFza3RhZ3Mgc3RkZXJyJywgc3RkZXJyKVxuICAgICAgICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkRXJyb3IoJ0ZhaWxlZCB0byBydW4gaGFza3RhZ3MnLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayxcbiAgICAgICAgICAgICAgICBkaXNtaXNzYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVzID0gZGF0YS5zcGxpdChFT0wpXG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcy5zbGljZSgwLCAtMSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgbGluZSA9PT0gJ1xceDBjJzpcbiAgICAgICAgICAgICAgZm4gPSB0cnVlXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIGZuOlxuICAgICAgICAgICAgICBmbiA9IGZhbHNlXG4gICAgICAgICAgICAgIGNvbnN0IHJlcyA9IC9eKC4qKSxcXGQrJC8uZXhlYyhsaW5lKVxuICAgICAgICAgICAgICBpZiAocmVzID09PSBudWxsKSBjb250aW51ZVxuICAgICAgICAgICAgICBjb25zdCBbLCBzcmNdID0gcmVzXG4gICAgICAgICAgICAgIGN1cmZpbGUgPSBuZXcgTWFwKClcbiAgICAgICAgICAgICAgdGhpcy50YWdzLnNldChzcmMsIGN1cmZpbGUpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb25zdCByeHIgPSAvXiguKilcXHg3ZiguKilcXHgwMShcXGQrKSwoXFxkKykkLy5leGVjKGxpbmUpXG4gICAgICAgICAgICAgIGlmIChyeHIgPT09IG51bGwpIGNvbnRpbnVlXG4gICAgICAgICAgICAgIGNvbnN0IFssIGNvbnRleHQsIHRhZ05hbWUsIGxpbmVOb10gPSByeHJcbiAgICAgICAgICAgICAgbGV0IG9iaiA9IGN1cmZpbGUuZ2V0KHRhZ05hbWUpXG4gICAgICAgICAgICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9iaiA9IFtdXG4gICAgICAgICAgICAgICAgY3VyZmlsZS5zZXQodGFnTmFtZSwgb2JqKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9iai5wdXNoKHsgY29udGV4dCwgbGluZTogcGFyc2VJbnQobGluZU5vLCAxMCkgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuaW5Qcm9ncmVzcyA9IGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHB1YmxpYyBsaXN0VGFncyh1cmk/OiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXM6IFN5bVJlY1tdID0gW11cbiAgICBpZiAoIXVyaSkge1xuICAgICAgdGhpcy50YWdzLmZvckVhY2goKHRhZ01hcCwgdXJpKSA9PlxuICAgICAgICB0YWdNYXAuZm9yRWFjaCgobGluZXMsIHRhZykgPT5cbiAgICAgICAgICBsaW5lcy5mb3JFYWNoKCh7IGNvbnRleHQsIGxpbmUgfSkgPT5cbiAgICAgICAgICAgIHJlcy5wdXNoKHsgdGFnLCB1cmksIGNvbnRleHQsIGxpbmUgfSksXG4gICAgICAgICAgKSxcbiAgICAgICAgKSxcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFnTWFwID0gdGhpcy50YWdzLmdldCh1cmkpXG4gICAgICBpZiAodGFnTWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGFnTWFwLmZvckVhY2goKGxpbmVzLCB0YWcpID0+XG4gICAgICAgICAgbGluZXMuZm9yRWFjaCgoeyBjb250ZXh0LCBsaW5lIH0pID0+XG4gICAgICAgICAgICByZXMucHVzaCh7IHRhZywgdXJpLCBjb250ZXh0LCBsaW5lIH0pLFxuICAgICAgICAgICksXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgcHVibGljIGZpbmRUYWcodGFnOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXM6IFN5bVJlY1tdID0gW11cbiAgICB0aGlzLnRhZ3MuZm9yRWFjaCgodGFnTWFwLCB1cmkpID0+IHtcbiAgICAgIGNvbnN0IGxpbmVzID0gdGFnTWFwLmdldCh0YWcpXG4gICAgICBpZiAobGluZXMgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gICAgICBsaW5lcy5mb3JFYWNoKCh7IGNvbnRleHQsIGxpbmUgfSkgPT4ge1xuICAgICAgICByZXMucHVzaCh7IHRhZywgdXJpLCBjb250ZXh0LCBsaW5lIH0pXG4gICAgICB9KVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgcHJpdmF0ZSBmaWxlc0NoYW5nZWQgPSAoZXZ0czogRmlsZXN5c3RlbUNoYW5nZUV2ZW50KSA9PiB7XG4gICAgZm9yIChjb25zdCBldnQgb2YgZXZ0cykge1xuICAgICAgaWYgKCFldnQucGF0aC5lbmRzV2l0aCgnLmhzJykgJiYgIWV2dC5wYXRoLmVuZHNXaXRoKCcubGhzJykpIGNvbnRpbnVlXG4gICAgICBzd2l0Y2ggKGV2dC5hY3Rpb24pIHtcbiAgICAgICAgY2FzZSAnY3JlYXRlZCc6XG4gICAgICAgICAgdGhpcy51cGRhdGUoZXZ0LnBhdGgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnbW9kaWZpZWQnOlxuICAgICAgICAgIHRoaXMudXBkYXRlKGV2dC5wYXRoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2RlbGV0ZWQnOlxuICAgICAgICAgIHRoaXMudGFncy5kZWxldGUoZXZ0LnBhdGgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncmVuYW1lZCc6XG4gICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICB0aGlzLnRhZ3MuZGVsZXRlKGV2dC5vbGRQYXRoISlcbiAgICAgICAgICB0aGlzLnVwZGF0ZShldnQucGF0aClcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGF0aHNDaGFuZ2VkID0gKHBhdGhzOiBzdHJpbmdbXSkgPT4ge1xuICAgIGNvbnN0IHJlbW92ZWRQYXRocyA9IHRoaXMucGF0aHMuZmlsdGVyKChwKSA9PiAhcGF0aHMuaW5jbHVkZXMocCkpXG4gICAgY29uc3QgYWRkZWRQYXRocyA9IHBhdGhzLmZpbHRlcigocCkgPT4gIXRoaXMucGF0aHMuaW5jbHVkZXMocCkpXG4gICAgaWYgKHJlbW92ZWRQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICBBcnJheS5mcm9tKHRoaXMudGFncy5rZXlzKCkpXG4gICAgICAgIC5maWx0ZXIoKGYpID0+IHJlbW92ZWRQYXRocy5zb21lKChwKSA9PiBmLnN0YXJ0c1dpdGgocCArIHNlcCkpKVxuICAgICAgICAuZm9yRWFjaCgoaykgPT4gdGhpcy50YWdzLmRlbGV0ZShrKSlcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIGFkZGVkUGF0aHMpIHtcbiAgICAgIHRoaXMudXBkYXRlKHBhdGgpXG4gICAgfVxuICAgIHRoaXMucGF0aHMgPSBwYXRoc1xuICB9XG59XG4iXX0=